7. Lokalizasyon ve Uluslararasılaştırma
Flutter, çok dilli ve uluslararası uygulamalar için kapsamlı destek sunar. Uygulama çok dilli olduğunda,
metinler tüm dillerdeki eşdeğerlerine çevirilir ve kullanıcı ara yüzü (UI), seçilen dile göre uygun metin ve
yön (LTR/RTL) ile güncellenir. Bu süreçte mimari olarak Localization katmanı hazırlanmalı; kütüphane
olarak Flutter’ın flutter_localizations paketi ve intl kullanılır (ç) ve kod üreteci ( flutter
gen-l10n ) ile .arb veya JSON dosyalarından lokalize sınıf ( AppLocalizations ) oluşturulur
.
Mimari öneri: MaterialApp ’i localizationsDelegates ve supportedLocales
parametreleriyle yapılandırın. Örneğin:
MaterialApp(
locale: ref.watch(appLanguageProvider), // Riverpod
ile kontrol edilen aktif dil
supportedLocales: const [Locale('en'), Locale('tr')], //
Desteklenen diller
localizationsDelegates: const [
AppLocalizations.delegate, // Üretilen
lokalizasyon sınıfı
GlobalMaterialLocalizations.delegate,
GlobalWidgetsLocalizations.delegate,
GlobalCupertinoLocalizations.delegate,
],
home: const HomePage(),
);
Bu düzenlemeyle Flutter, uygulamayı kullanıcı dile uygun hale getirir ve metin yönelimini (LTR/
RTL) otomatik ayarlar .
Araçlar/Kütüphaneler: flutter_localizations ve intl (Flutter SDK). Lokalizasyon kodu
üretimi için flutter gen-l10n . Tercihe bağlı olarak easy_localization, GetX gibi paketler de
kullanılabilir. Kaynak kodda çeviri dosyaları .arb (Flutter önerisi) veya JSON (easy_localization
vb.) olabilir. Örneğin, lib/l10n/app_en.arb , lib/l10n/app_tr.arb gibi dosyalar
oluşturup l10n.yaml ile konfigüre edin .
Kod örneği: Medium yazısındaki örnekte Riverpod kullanılarak dil yönetimi şöyle yapılmış
:
// StateNotifier ile dil yönetimi
class AppLanguageNotifier extends StateNotifier<Locale> {
AppLanguageNotifier() : super(const Locale('en'));
Future<void> fetchLocale() async {
final prefs = await SharedPreferences.getInstance();
final code = prefs.getString('language_code');
1
2
•
3
•
4 2
• 2
5
1
if (code != null) state = Locale(code);
}
Future<void> changeLanguage(Locale newLoc) async {
final prefs = await SharedPreferences.getInstance();
if (state != newLoc) {
state = newLoc;
await prefs.setString('language_code', newLoc.languageCode);
}
}
}
final appLanguageProvider = StateNotifierProvider<AppLanguageNotifier,
Locale>(
(ref) {
final notifier = AppLanguageNotifier();
notifier.fetchLocale();
return notifier;
},
);
// MaterialApp içinde
final locale = ref.watch(appLanguageProvider);
return MaterialApp(
locale: locale,
supportedLocales: const [Locale('en'), Locale('fr')],
localizationsDelegates: const [AppLocalizations.delegate,
GlobalMaterialLocalizations.delegate, /*...*/],
home: const ChooseLanguagePage(),
);
Bu düzen ile uygulama açıldığında daha önce seçilmiş dil ( SharedPreferences ) yüklenir ve
ChangeLanguage çağrısı ile devlet ( state ) güncellenir . Kullanıcı arayüzü
( ConsumerWidget ) değişen locale ile yeniden çizilir.
Potansiyel sorunlar ve çözümler:
Eksik çeviriler: Bir dil dosyasında bazı anahtarlar eksik kalabilir. Bu durumda
AppLocalizations.of(context)?.key null dönebilir veya varsayılan dil ( en ) kullanılır.
Çözüm: Geliştirme aşamasında testlerle eksik anahtar tespiti yapın ve CI’da çeviri kontrolü
sağlayan script’ler ekleyin.
Türkçe karakterler/plurals: Diller farklı çoğul kuralları kullanır. intl paketinin ARB sözdizimi
(plural, select) ile farklı çoğul, cinsiyetli versiyonlar tanımlanabilir . Örneğin {count,
plural, =0{Hiç kişi yok} =1{1 kişi} other{{count} kişi}} .
RTL düzen: Arapça, İbranice gibi diller için sağdan-sola (RTL) düzen gerekir. Flutter,
flutter_localizations ile yön otomatik uyum sağlar . Yine de özel durumlarda
Directionality(textDirection: TextDirection.rtl, child: ...) veya
AlignmentDirectional kullanın. Örneğin, Padding ve EdgeInsetsDirectional ile
sağa/sola göre pozisyon verin. Dize içindeki sayılar, simgeler gibi öğelerin sağa kayması
gerekebilir. Testlerde mutlaka bir RTL dil seçip arayüzü kontrol edin.
2 5
•
•
•
6 7
•
3
2
Performans, bakım ve test: Lokalizasyon, derleme aşamasında gerçekleşir; çalışma zamanında
sadece uygun dize dosyası yüklenir. Bu nedenle performans yükü düşüktür. Büyük metinler veya
çok sayıda dil, uygulama boyutunu arttırır (her dil için ek kod). Bu artışı göze alarak sadece
ihtiyaç duyulan diller eklenmelidir. Bakım kolaylığı için her dil için ayrı dosya kullanın, dosya
isimlerini ISO kodu ile app_en.arb , app_fr.arb gibi düzenleyin . Test edilebilirlik
için:
Birim testi: LocaleNotifier gibi provider’ları model olarak test edin (ör. changeLanguage
metodu pref değiştiriyor mu?).
Widget/Entegrasyon testi: Farklı Locale değerleriyle uygulamayı sarmalayıp arayüzün doğru
çevrildiğini doğrulayın. Cihaz dili değiştirme senaryosu simüle edin.
Kod kalite: flutter_gen veya intl_utils gibi kod jenerasyon araçları kullanarak yazım
hatalarından kaçının.
Metinsel şema/akış: Örneğin kullanıcı dil değiştirdiğinde katmanlar arası akış şu şekildedir:
UI (Dil Seçenekleri Ekranı) → Application Layer (Kullanıcı seçim
işleyicisi) → Domain/State (Riverpod dili güncelleme) → Persistence
(SharedPreferences’a kaydetme) → UI (MaterialApp locale değişimi ile
yeniden yükleniyor)
Böylece UI güncellenirken statik çeviri tabloları (AppLocalizations) yeniden uygulanır.
Use-case senaryoları:
Senaryo: Kullanıcı uygulamayı ilk açtığında cihaz dili Türkçe ise arayüz Türkçe görüntülenir. Aksi
takdirde varsayılan İngilizce. Bunu WidgetsBinding.instance.window.locale veya
Platform.localeName ile alıp, eğer destekliyorsa kullanın.
Senaryo: Kullanıcı Ayarlar’dan dili Fransızca’ya çevirir. Bu durumda
LocaleNotifier.changeLanguage(Locale('fr')) çağrılır. Bütün ekranlar,
AppLocalizations.of(context)! ile sağlanan Fransızca metinleri kullanarak yeniden çizilir.
Senaryo: Dinamik içerik çevirisi. Örneğin backend’den gelen içeriğin birden çok dilde hali varsa, API
sorgusunda dil tercihi gönderin. UI katmanında gelen JSON içeriği Riverpod veya Notifier
üzerinden alıp uygun dilde gösterin (kullanıcı dilleri arasında geçişte backend’den ilgili dilde
içerik almanız gerekebilir).
Performans ve kapasite tahmini: Lokalizasyon metinlerinin depolanması çok az yer kaplar
(birkaç kB dil başına). Dize erişimi tam önbelleğe alındığından, UI’da metin gösterimi neredeyse
anında olur (ortalama <1ms). Ana gecikme, cihazın locale algılaması ve uygulamayı yeniden
çizme süresidir (genellikle <100ms). Yeni dil eklemeye bağlı olarak ABI boyutu artar; her dil
~10-20KB kaynak kod büyümesi demektir. Çeviri akışları ve placeholder/numara dönüşümleri
intl tarafından optimize edilir.
8. Offline-First ve Önbellek Stratejileri
Kullanıcı çevrimdışı olsa bile temel işlevlerin çalışmasını sağlamak için uygulamayı “offline-first” olarak
tasarlamak kritik. Flutter’da Riverpod ile önbellekleme ve state yönetimi; Supabase ile veri
•
8 9
•
•
•
•
•
•
•
•
•
3
senkronizasyonu; GraphQL/REST seviyesinde cache; ağ durumu takibi ve retry mekanizmaları birlikte
kullanılmalıdır.
Riverpod ile Cache Yönetimi
Mimari öneri: Verileri yönetmek için FutureProvider / StreamProvider veya yeni
AsyncNotifierProvider kullanın. Önbellek stratejisi için Riverpod’un varsayılan yaşam
döngüsü davranışını özelleştirin. Örneğin, standart (non-autoDispose) NotifierProvider ile
veriyi uzun süre saklayabilir, yoksa autoDispose ekleyerek kullanılmazsa serbest
bırakabilirsiniz . Gerektiğinde ref.keepAlive() ile veriyi aktif tutabilir veya
ref.onCancel() içinde zaman aşımı ile temizleme yapabilirsiniz .
Araçlar/Kütüphaneler: flutter_riverpod . Gerekirse riverpod_sqflite ile deneysel
offline persist (Riverpod 3 ile gelen özellik) kullanabilirsiniz . Veri modellerini serileştirmek için
freezed ve json_serializable önerilir. Performans için AsyncNotifier (Riverpod 3+)
cache davranışını yönetmeye uygundur.
Kod örneği: Basit bir önbellek mekanizması için aşağıdaki gibi autoDispose kullanan bir
AsyncNotifier örneği:
@riverpod
class ItemsNotifier extends _$ItemsNotifier {
@override
Future<List<Item>> build() async {
// Öncelikle cache varsa döndür
final cached = await localDb.getItems();
if (cached.isNotEmpty) {
return cached;
}
// Yoksa ağdan çek
final items = await api.fetchItems();
// Alınan veriyi cache’e kaydet
await localDb.saveItems(items);
return items;
}
Future<void> refresh() async {
state = const AsyncLoading();
final items = await api.fetchItems();
await localDb.saveItems(items);
state = AsyncData(items);
}
}
// UI’da:
final itemsAsync = ref.watch(itemsNotifierProvider);
Burada, build() başlangıçta önce SQLite’dan cache kontrolü yapıyor, eğer varsa cached
direkt dönüyor. Ağ isteği yalnızca cache yoksa yapılıyor. Cache yazımı ve state güncellemesi ile
•
10
11
•
12
•
4
offline-okuyabilirlik sağlanıyor. autoDispose bu provider’ın ekran kapanınca bellekten
temizlenmesini sağlar. Geniş veri için keepAlive: true ile cache süresini uzatabilirsiniz .
Potansiyel sorunlar ve çözümler:
Yinelenen istekler: autoDispose kullanırken her dinleyici eklenişinde yeniden fetch olabilir.
Gerekirse keepAlive ile uzun süreli cache yapın veya değişiklik olmadığında cevap verilmesini
sağlamak için kontrol ekleyin.
Cache bozulması: Verinin güncelliği önemli ise TTL (Time-to-Live) uygulayın. Örneğin, bir
AsyncNotifier içinde ref.onCancel olayında bir Timer başlatıp süresi dolunca yeniden fetch
yaptırmak mümkün .
State senkronizasyonu: Offline modda StateNotifier’ın verisi uygulama kapansa bile kaybolur.
Riverpod 3’ün offline persist özelliği kullanılmadıysa (hala deneysel) bu durumda veri kaybolur.
Bunu çözmek için state’i SQLite’a kaydedip build() başladığında geri yükleyebilirsiniz.
Örneğin, persist() çağrısıyla otomatik senkronize sağlayan yapı (Riverpod 3) kullanılabilir
.
Performans, bakım, test: Riverpod önbellekleme akıllıdır, genelde aktif dinleyici varken veri
bellekte tutulur. keepAlive ile AppScope’ta tutulan veri uygulama boyunca kalır (bazı MB
bellek kullanabilir). Test ederken;
Birim testi: ItemsNotifier gibi Provider’ı doğrudan test edin, ağdan ve cache’den veri
geldiğinde doğru state döndüğünü doğrulayın.
Widget testi: Bağlı widget’ı cache’li ve olmayan durumlarda çalıştırın.
Sorun: Yüksek bellek tüketimi gerekiyorsa (örneğin büyük resimler/medya), sadece ID veya
özetleri cache’leyin, büyük datayı talep üzerine alın.
Katmanlar arası akış: UI → State Notifier → (Önbellek)→ Ağ/API. Örneğin bir liste ekranı
açıldığında: UI ref.watch(itemsProvider) ile provider’ı tetikler → build() metodu çalışır
→ önce lokal DB’den veriyi alırsa hızlıca döndürür → ardından (isteğe göre) arkaplanda API’den
güncel veri çekip cache’e yazar.
Use-case senaryoları:
Senaryo: Kullanıcı bir listeyi ilk kez indiriyor. Uygulama önce cache’e bakar (boş), API’den veriyi
çeker, UI’ya gösterir ve SQLite’a kaydeder.
Senaryo: Kullanıcı aynı listeyi tekrar açıyor (online). Cache mevcut, önce SQLite’tan döner (sürekli
ağda değilse bile), arayüz hemen veriyi gösterir. Arkaplanda sunucu kontrolü yapılıp yeni veri
varsa günceller (lazy-refresh).
Senaryo: Kötü ağda veya offline. Cache’te eski veri varsa gösterilir; yoksa kullanıcıya “şu an veri
yüklenemiyor” bildirimi yapılır. Offline modda yapılan “beğeni” gibi işlemler (aksi belirtilmedikçe)
yerel queue’da tutulur (bkz. Brick şeması).
Performans ve kapasite tahminleri: Keep-alive olmayan basit veri cache’leri, saniyeler içinde
serbest bırakılır. keepAlive: true yapıldığında bellekte kalır; örneğin birkaç bin nesne birkaç
MB RAM tutabilir. Riverpod 3 offline persist ile her provider ~MB düzeyinde disk alanı kullanabilir
(Tablo: JSON veriler genellikle küçüktür). Cache invalidation süresi örneğin 10 dakika, yoksa her
başlatmada eski veri görüntülenebilir.
10
•
•
•
11
•
12
•
•
•
•
•
•
•
•
•
•
5
Supabase ile Offline Sync Mekanizması
Mimari öneri: Supabase’ın Flutter SDK’sı offline desteği sınırlıdır. Bu nedenle Brick (Brick Offline
First for Supabase) gibi kütüphaneler kullanılabilir . Brick, Supabase tablo verisini otomatik
olarak SQLite’a yedekler ve offline işlemleri kuyruğa alır. Mimaride, veri katmanına bir Repository
soyutlaması ekleyerek doğrudan Supabase yerine Brick Repository kullanın. Böylece UI
katmanından iş mantığı ayrılmış olur.
Araçlar/Kütüphaneler:
brick_offline_first_with_supabase , brick_sqlite , brick_supabase : Brick
kütüphaneleri .
sqflite veya drift (Brick otomatik ayarlar Sqlite kullanır).
supabase_flutter (online işlemler için).
Kod örneği: Supabase model tanımı Brick ile şöyle yapılır :
@ConnectOfflineFirstWithSupabase(supabaseConfig:
SupabaseSerializable(tableName: 'users'))
class User extends OfflineFirstWithSupabaseModel {
final String name;
@Supabase(unique: true) @Sqlite(index: true, unique: true)
final String id;
User({String? id, required this.name}) : this.id = id ?? const
Uuid().v4();
}
Bu sınıfı oluşturup build_runner ile kod üretildikten sonra Brick otomatik olarak lokal DB
migrasyonlarını ve Supabase çevirici adaptörlerini oluşturur . Repository kullanımı:
final repo = BrickRepository(); // Örnek singleton repository
// Veriyi al ve otomatik olarak önce SQLite, sonra gerekiyorsa Supabase:
final users = await repo.get<User>();
// Yeni kullanıcı ekle (lokal kaydet, online bekle):
await repo.upsert(User(name: 'Alice'));
Bu çağrılar hem online hem offline çalışır: SQLite’ta bir satır yaratılır ve eğer çevrimdışı ise
Supabase isteği kuyruğa eklenir. Çevrimiçi dönüldüğünde Brick bu isteği otomatik yeniden dener.
Potansiyel sorunlar ve çözümler:
Çakışmalar: Aynı kaydı farklı cihazlarda offline olarak güncelleme çakışabilir. Brick’in temel
senkronizasyonu “son yazan kazansın” prensibine göredir. Karmaşık durumlar için kendinize
özgü çakışma çözümü mantığı (örn. zaman damgası karşılaştırma) ekleyin veya sonradan
kullanıcı onayı gerektirin.
RLS (Row Level Security): Supabase üzerinde RLS aktifse, offline uygulama için geçici token
süresi veya offline önbellek erişimi düşünülebilir. Offline işlem kuyruğunda, izinlerin kontrolünü
sunucu tarafında sağladığınızdan emin olun.
Senkronizasyon gecikmesi: Kullanıcı offline modda çok sayıda değişiklik yaptıysa,
bağlandığında bu değişikliklerin geri gönderimi uzun sürebilir. Brick varsayılan olarak aralıksız
•
13
•
•
14 15
•
•
• 16 17
18
•
•
•
•
6
retry yapar . Gerektiğinde UpsertPolicy.awaitRemote ayarı ile bazı işlemleri senkron
hallaştırabilirsiniz.
Performans, bakım, test: Brick kullanarak çoğu karmaşık offline detay Brick tarafından
halledilir. Performans olarak:
Okuma: Lokal DB’den okuma MS mertebesinde, kabaca API hızından çok daha hızlıdır.
Yazma: Bir upsert önce SQLite’a, sonra arkaplanda Supabase’a iletilir; bu süreçte uygulama
takılmaz.
Retry: Brick sonsuz retry ile offline modda bile veriyi eninde sonunda gönderir . Queue
işlemleri hafifdir.
Test: SupabaseMockServer kullanarak sunucu etkileşimlerini izole test edin . Brick kendi
test altyapısını sunar, model dictionary üzerinden örnek veri ile birimler testi kolaydır .
Katmanlar arası akış: UI → Use Case (Domain) → Brick Repository → LocalDB/Supabase. Örneğin,
kullanıcı bir mesaj gönderdiğinde akış: UI (Mesaj Gönder butonu) → MessageSendUseCase
çağrısı → BrickRepository.upsert<Message>(message) → SQLite’a yaz, eğer offline ise
Kuyruğa ekle→ (çevrimiçi dönüldüğünde) Brick kuyruktaki mesajı Supabase’e yollar .
Use-case senaryoları:
Senaryo: Kullanıcı ürün beğendi (like) offline. UI hemen beğeni sayısını artırır, Brick kayıt oluşturur.
Çevrimdışı olduğu için bu upsert çevrimiçi platforma kuyruğa alınır. Ağa dönünce otomatik
gönderilip geri bildirim alınır (örn. beğeni sayısı güncellenir).
Senaryo: Kullanıcı offline modda içerik görüntülüyor. Uygulama daha önce çekilmiş içeriği (haber
akışı vs.) SQLite’dan anında gösterir. Arkada veri yenileme isteği bekler veya erteleyebilir.
Senaryo: Offline güncellemeler birleştirme. Bir kullanıcı offlineyken profilini değiştirip, fotoğraf
yüklerse bu veriler lokal DB’de toplanır. Bağlantı geri geldiğinde tüm değişiklikler sırasıyla
sunucuya yansıtılır.
Performans ve kapasite tahminleri:
DB Satır Sayısı: Uygulama içeriği arttıkça SQLite veritabanı milyonlarca satır barındırabilir.
Performans için önemli tabloları index’leyin (Brick @Sqlite(index: true) kullanır). Satır
sayısı 1M’i aşarsa tablonun bölümlenmesi (partition) gerekebilir.
API Yanıt Süresi: Lokal önbellek <100ms, çünkü diske erişim SSD <10ms. Yalnızca ilk erişim için
veya senkronizasyon sırasında ağ çağrısı yapılır (<200ms hedef).
Retry Kuyruk Bekleme: Brick’in kuyruğu standard olarak sürekli deneyerek 30 güne kadar
yeniden deneyecek şekilde tasarlanmıştır .
Network Overhead: Offline modda ağ tüketimi yoktur. Senkronizasyon geldiğinde tek seferde
birden çok isteği ardışık göndermek bant genişliği kullanımını optimize eder.
GraphQL Caching
Mimari öneri: Eğer uygulama GraphQL kullanıyorsa, graphql_flutter paketi ile istemci tarafı
cache (InMemory/Hive) yapılandırılabilir. Alternatif olarak Brick’in GraphQL offline desteği de
değerlendirilebilir . GraphQL’de okunabilir veriler için GraphQLCache ve HiveStore
kullanın; yazma (mutation) için ise offline kuyruk (Brick, Apollo gibi). Okumalar için
QueryOptions ’ta fetchPolicy ayarları (örn. cacheFirst ) yapılmalıdır.
13
•
•
•
• 19
• 20 21
21
•
13
•
•
•
•
•
•
•
•
19
•
•
22
7
Araçlar/Kütüphaneler: graphql_flutter (client), hive_flutter (kayıtlı önbellek), Brick
OfflineFirstWithGraphql . hive veya shared_preferences ile ek manuel saklama da
mümkün (basit veriler için).
Kod örneği: GraphQLClient kurulumu (cache ile):
final HttpLink httpLink = HttpLink('https://example.com/graphql');
final WebSocketLink wsLink = WebSocketLink('wss://example.com/graphql');
final Link link = Link.split(
(request) => request.isSubscription,
wsLink, httpLink,
);
final GraphQLClient client = GraphQLClient(
link: link,
cache: GraphQLCache(store: HiveStore()), // Hive ile kalıcı cache
);
Daha sonra GraphQLProvider ile tüm uygulamayı sarmalayın. Sorgular:
client.query(QueryOptions(...)) kullanın. Önbellek için
QueryOptions(fetchPolicy: FetchPolicy.cacheAndNetwork) gibi seçenekleri
ayarlayın. Brick GraphQL örneğinde ise model tanımıyla otomatik sorgulama yapılır :
final repository = OfflineFirstWithGraphqlRepository();
final users = await
repository.get<User>(); // GraphQL sorgu, bellek ya da SQLite cache’i
kullanarak döndürür .
Potansiyel sorunlar ve çözümler:
Önbelleğin senkron kalmaması: Varsayılan olarak GraphQLClient cache’i bellekte, kalıcı değil.
HiveStore kullanarak kalıcı cache yapın. Ancak veritabanındaki son değişiklikleri almak için
sorgularınıza arada bir server sorgusu (polling veya manuel refetch) ekleyin. Brick kullanılırsa,
subscribe<>() ile anlık güncellemeler alabilirsiniz .
Büyük sorgu belgeleri: Brick’in GraphQL örneğinde, model üzerinden otomatik belge üretilir
. Çeşitli veriler gerekiyorsa iki model (ör: UserLight , UserFull ) oluşturup farklı sorgular
yapabilirsiniz (optimize amaçlı) .
Mutation offline: Brick GraphQL’de “Retry Queue” ile offline mutation’lar bir kuyrukta tutulur
. Kendi GraphQL ortamınız varsa graphql_flutter ’ın OfflineLink gibi paketler veya
Apollo Client benzeri çözümler araştırılabilir (Örneğin Hive’ın “offline GraphQL” dokümanı).
Performans, bakım, test:
Cache süresi: Tekrar kullanılacak veriler için örneğin 5 dakika önbellek süresi kullanılabilir
(GraphQL cache’in süre kontrolü manuel yapılabilir).
Bellek kullanımı: HiveStore belleği diskte tutar, RAM kullanım minimaldir. Büyük veri objeleri
Hive’da yer kaplayabilir; gereksiz alanları sorgudan çıkartın.
Test: GraphQL sorgularını mock’lamak için graphql_flutter test araçları veya Brick
kullanıyorsanız mock repository ile test yapın. Önbelleğin doğru çalıştığını entegrasyon
testleriyle kontrol edin (ör: ilk sorguda network, sonrakiler cache).
•
22
•
23
22
22
•
•
24
•
25
26
•
19
•
•
•
•
8
Performans testi: Ağ yanıt sürelerine ek olarak cache okuma süresini ölçün. Hedef: cache hits
<50ms, cache write ~100ms. 1K, 10K, 100K kayıt (örneğin brick SQL olarak) testi yaparak SQLite
sorgu performansını kontrol edin.
Katmanlar arası akış: UI → GraphQL Client/Repository → Cache/Network → API. Örneğin:
UI (Feed ekranı açıldı) → Application (FeedUseCase) →
Repository.getPosts()
 → GraphQLClient (önce Hive cache'e bakar, yoksa HTTP sorgusu) →
 Supabase GraphQL API → (sonuç lokal/Hive’a kaydedilir) → UI’ya döner.
Senaryo: Kullanıcı feed’e göz atarken ilk defa bağlantılıysa API çağrısı yapar; sonraki açışlarda
önbellekten hızlıca gösterir. Kullanıcı offline ise önceki önbelleği gösterir, ağ isteği atılmaz.
Network Durumu İzleme ve Retry Mekanizmaları
Mimari öneri: Uygulamada sürekli connectivity_plus veya
internet_connection_checker gibi paketlerle ağ durumu takip edin. Önbellek veya offline
queue kullanıldığında, internet geldiğinde kuyruk tüketimi tetiklenebilir. Retry için akıllı strateji
belirleyin: örneğin araya Retry paketleriyle üssel geri çekilmeli yeniden deneme ekleyin veya
Brick’in offline kuyruğunu kullanın .
Araçlar/Kütüphaneler:
connectivity_plus : Ağa bağlı olup olmadığını ve bağlantı türünü izler .
internet_connection_checker : Ping benzeri aktif bağlantı testi için.
dio + dio_retry (REST kullanılıyorsa) veya retry paketi (Dart) ile yeniden deneme
stratejileri.
Kod örneği: Connectivity örneği:
// Provider ile global network durumunu izleme
final connectivityProvider = StreamProvider<ConnectivityResult>((ref) {
return Connectivity().onConnectivityChanged;
});
// Kullanım:
ref.listen<AsyncValue<ConnectivityResult>>(connectivityProvider, (prev,
next) {
final status = next.value;
if (status != ConnectivityResult.none) {
// Çevrimiçiye geçildi, offline kuyrukları gönder
BrickRepository().syncAllPending();
}
});
Bu örnekte, ağ bağlanır bağlanmaz syncAllPending() gibi metotlarla Brick’in tüm bekleyen
işlemleri tamamlamasını tetikleyebilirsiniz.
Potansiyel sorunlar ve çözümler:
•
•
•
19
•
• 27 28
•
•
•
•
9
Yanıltıcı bağlantı durumu: connectivity_plus sadece ağ tipini verir; gerçek internet erişimi
olmayabilir. Bu nedenle kritik API çağrılarında hata yakalama ve yeniden deneme uygulamak
gerekir. internet_connection_checker ile gerçek bağlantı durumunu kontrol edin.
Sürekli retry: Kullanıcı zayıf bir ağdaysa istekler çokça başarısız olabilir. Üssel geri çekilme
(exponential backoff) kullanın ve maksimum deneme sayısı belirleyin. Örneğin retry paketi ile
3 deneme yapın (1s, 2s, 4s aralık) ardından kullanıcıya hata mesajı gösterin.
UI geri bildirim: Network yokken kullanıcı bir işlem yapmaya çalışırsa (ör: gönder tuşuna
basmak), önce “offline” uyarısı verip işlemi kuyruklayın. Kullanıcıya işlemin offline olduğuna dair
görsel bir işaret (Snackbar vs.) ekleyin.
Performans, bakım, test:
Dinleme yükü: Connectivity stream dinleme ışık yük getirmez. Sadece değiştiğinde callback
tetiklenir. Birden fazla listener varsa bir provider üzerinden tek dinleme yapıp paylaşmak iyi
uygulamadır.
Retry performansı: Kısa süreli offline’larda hemen retry; uzun süreli offline durumlarında
kullanıcıya manuel “yenile” seçeneği sunabilirsiniz.
Test: Ağ durumu simülasyonu ile test yapın (ör. simulator/kontroller). Retry senaryosunu bir test
framework’te API endpoint hata verecek şekilde tetikleyip doğru davrandığını görün.
Connectivity mock’ları kullanarak farklı durumları simüle edin.
Katmanlar arası akış: Örneğin Offline “beğeni” işlemi senaryosu: Kullanıcı (UI) beğeni butonuna
basar → Uygulama BeğeniUseCase çalışır → Brick Repository üzerinden
upsert<Like>(like) çağrılır → Lokal DB’ye kaydedilir (UI güncellenir) → (Offline olması
durumunda) brick kuyruğa ekler. Sonra ağa bağlanma durumu: Connectivity değişimi yakalanır
→ Queued işlemler Brick tarafından gönderilir → Supabase’a ulaştığında sunucudan yanıt alınıp
(örn. API timestamp) local DB güncellenir.
Use-case senaryoları:
Senaryo: Offline moddayken profil güncellemesi. Kullanıcı offline iken profilini değiştirir. Uygulama
değişikliği lokal DB’ye yazar. Bağlantı gelince updateProfile isteği gönderilir. UI bu süre
boyunca lokal veriyi gösterir.
Senaryo: Zayıf bağlantı anında yenileme. Kullanıcı Zayıf Wi-Fi’da push bildirimine hızlıca tepki verir
(örn. yeni mesaj aç). Uygulama hemen lokal veriyi kullanarak ekranı gösterir, arka planda
server’dan en güncel mesajları çeker. Eğer ağ tamamen kesilirse “tekrar dene” butonu önerilir.
Senaryo: Arka planda veri güncelleme. Uygulama açıldığında (foreground) veya background’da
yavaş yavaş önbelleği yenilemek için pull-to-refresh mekanizması eklenir. Bu sayede ağ
gelince önbellek güncellenir ve UI tekrar çizilir.
Performans ve kapasite tahminleri:
Ağ gecikmesi hedefleri: Hızlı yanıt için önbellekten okunmayan sorgular (örneğin yeni veri
yazma) için <500ms, önbellekten okuma için <50ms hedefleyin.
Retry gecikmeleri: Başarısız bir istek için 3-5 saniye aralıklı 3 deneme yeterli olabilir. Zaman
aşımı için ~5s, maksimum 3 deneme sonra kullanıcı bildirimine geçilebilir.
Bağlantı kontrol sıklığı: Genellikle bir provider olarak
Connectivity().onConnectivityChanged ile anlık dinleyin. Ardından uygulama açıkken
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
10
her 30s’de bir ping test (isteğe bağlı) olabilir. Battery düşünüldüğünde kontroller arası uzun
tutabilirsiniz.
Kaynaklar: Flutter’ın resmi i18n dokümantasyonu , Riverpod localization örnekleri , Brick
offline blog ve The Guild GraphQL blog temel referanslar olarak kullanılmıştır.
i18n | Flutter
https://docs.flutter.dev/ui/accessibility-and-internationalization/internationalization
Flutter Localization with Riverpod and SharedPreferences. | by Eman Yaqoob |
Medium
https://medium.com/@emanyaqoob/flutter-localization-with-riverpod-and-sharedpreferences-d3919fb9bb02
Riverpod Data Caching and Providers Lifecycle: Full Guide
https://codewithandrea.com/articles/flutter-riverpod-data-caching-providers-lifecycle/
What's new in Riverpod 3.0 | Riverpod
https://riverpod.dev/docs/whats_new
Building offline-first mobile apps with Supabase, Flutter and Brick
https://supabase.com/blog/offline-first-flutter-apps
Flutter GraphQL | The Guild | Hive
https://the-guild.dev/graphql/hive/blog/offline-graphql-the-easy-parts
flutter - Offline mode using graph_flutter - Stack Overflow
https://stackoverflow.com/questions/68001092/offline-mode-using-graph-flutter
connectivity_plus | Flutter package
https://pub.dev/packages/connectivity_plus
1 29 2 5
13 30 19
1 3 6 7 29
2 4 5 8 9
10 11
12
13 14 15 16 17 18 20 21 30
19 22 24 25 26
23
27 28
11