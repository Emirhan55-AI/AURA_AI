import 'package:dartz/dartz.dart';

import '../../../../core/error/failure.dart';
import '../../domain/entities/clothing_item.dart';
import '../../domain/repositories/i_user_wardrobe_repository.dart';
import '../models/clothing_item_model.dart';
import '../services/wardrobe_service.dart';

/// Concrete implementation of the IUserWardrobeRepository interface
/// Follows Clean Architecture principles by implementing the domain contract
/// Converts between domain entities and data models, handling business logic transformations
class UserWardrobeRepository implements IUserWardrobeRepository {
  final WardrobeService _wardrobeService;

  /// Constructor that initializes the repository with a wardrobe service
  const UserWardrobeRepository({
    required WardrobeService wardrobeService,
  }) : _wardrobeService = wardrobeService;

  @override
  Future<Either<Failure, List<ClothingItem>>> fetchItems({
    int page = 1,
    int limit = 20,
    String? searchTerm,
    List<String>? categoryIds,
    List<String>? seasons,
    bool showOnlyFavorites = false,
    String? sortBy,
  }) async {
    try {
      // Fetch raw data from the service layer
      final result = await _wardrobeService.fetchItemsRaw(
        page: page,
        limit: limit,
        searchTerm: searchTerm,
        categoryIds: categoryIds,
        seasons: seasons,
        showOnlyFavorites: showOnlyFavorites,
        sortBy: sortBy,
      );

      return result.fold(
        // Pass through failures unchanged
        (failure) => Left(failure),
        // Convert raw data to domain entities
        (rawItems) {
          try {
            final clothingItems = rawItems
                .map((rawItem) => ClothingItemModel.fromJson(rawItem).toEntity())
                .toList();
            return Right(clothingItems);
          } catch (e) {
            return Left(ValidationFailure(
              message: 'Failed to parse clothing items: ${e.toString()}',
              code: 'PARSE_ERROR',
              details: e,
            ));
          }
        },
      );
    } catch (e) {
      return Left(UnknownFailure(
        message: 'Unexpected error in repository: ${e.toString()}',
        code: 'REPOSITORY_ERROR',
        details: e,
      ));
    }
  }

  @override
  Future<Either<Failure, ClothingItem>> addItem(ClothingItem item) async {
    try {
      // Convert domain entity to data model and then to JSON
      final itemModel = ClothingItemModel.fromEntity(item);
      final itemData = itemModel.toJson();

      // Remove ID field for new items (it will be generated by the database)
      itemData.remove('id');

      // Call the service layer
      final result = await _wardrobeService.addItemRaw(itemData);

      return result.fold(
        // Pass through failures unchanged
        (failure) => Left(failure),
        // Convert raw response to domain entity
        (rawItem) {
          try {
            final createdItem = ClothingItemModel.fromJson(rawItem).toEntity();
            return Right(createdItem);
          } catch (e) {
            return Left(ValidationFailure(
              message: 'Failed to parse created item: ${e.toString()}',
              code: 'PARSE_ERROR',
              details: e,
            ));
          }
        },
      );
    } catch (e) {
      return Left(UnknownFailure(
        message: 'Unexpected error while adding item: ${e.toString()}',
        code: 'REPOSITORY_ERROR',
        details: e,
      ));
    }
  }

  @override
  Future<Either<Failure, ClothingItem>> getItemById(String itemId) async {
    try {
      // Call the service layer
      final result = await _wardrobeService.getItemByIdRaw(itemId);

      return result.fold(
        // Pass through failures unchanged
        (failure) => Left(failure),
        // Convert raw response to domain entity
        (rawItem) {
          try {
            final clothingItem = ClothingItemModel.fromJson(rawItem).toEntity();
            return Right(clothingItem);
          } catch (e) {
            return Left(ValidationFailure(
              message: 'Failed to parse clothing item: ${e.toString()}',
              code: 'PARSE_ERROR',
              details: e,
            ));
          }
        },
      );
    } catch (e) {
      return Left(UnknownFailure(
        message: 'Unexpected error while fetching item: ${e.toString()}',
        code: 'REPOSITORY_ERROR',
        details: e,
      ));
    }
  }

  @override
  Future<Either<Failure, ClothingItem>> updateItem(ClothingItem item) async {
    try {
      // Validate that the item has an ID
      if (item.id.isEmpty) {
        return const Left(ValidationFailure(
          message: 'Cannot update item without valid ID',
          code: 'INVALID_ITEM_ID',
        ));
      }

      // Convert domain entity to data model and then to JSON
      final itemModel = ClothingItemModel.fromEntity(item);
      final itemData = itemModel.toJson();

      // Remove fields that shouldn't be updated directly
      itemData.remove('id');
      itemData.remove('user_id');
      itemData.remove('created_at');

      // Call the service layer
      final result = await _wardrobeService.updateItemRaw(item.id, itemData);

      return result.fold(
        // Pass through failures unchanged
        (failure) => Left(failure),
        // Convert raw response to domain entity
        (rawItem) {
          try {
            final updatedItem = ClothingItemModel.fromJson(rawItem).toEntity();
            return Right(updatedItem);
          } catch (e) {
            return Left(ValidationFailure(
              message: 'Failed to parse updated item: ${e.toString()}',
              code: 'PARSE_ERROR',
              details: e,
            ));
          }
        },
      );
    } catch (e) {
      return Left(UnknownFailure(
        message: 'Unexpected error while updating item: ${e.toString()}',
        code: 'REPOSITORY_ERROR',
        details: e,
      ));
    }
  }

  @override
  Future<Either<Failure, void>> deleteItem(String itemId) async {
    try {
      // Validate item ID
      if (itemId.isEmpty) {
        return const Left(ValidationFailure(
          message: 'Cannot delete item without valid ID',
          code: 'INVALID_ITEM_ID',
        ));
      }

      // Call the service layer for soft delete
      final result = await _wardrobeService.deleteItemRaw(itemId);

      return result.fold(
        // Pass through failures unchanged
        (failure) => Left(failure),
        // Return success
        (success) => const Right(null),
      );
    } catch (e) {
      return Left(UnknownFailure(
        message: 'Unexpected error while deleting item: ${e.toString()}',
        code: 'REPOSITORY_ERROR',
        details: e,
      ));
    }
  }

  @override
  Future<Either<Failure, ClothingItem>> toggleFavorite(
    String itemId,
    bool isFavorite,
  ) async {
    try {
      // Validate item ID
      if (itemId.isEmpty) {
        return const Left(ValidationFailure(
          message: 'Cannot toggle favorite without valid ID',
          code: 'INVALID_ITEM_ID',
        ));
      }

      // Call the service layer
      final result = await _wardrobeService.toggleFavoriteRaw(itemId, isFavorite);

      return result.fold(
        // Pass through failures unchanged
        (failure) => Left(failure),
        // Convert raw response to domain entity
        (rawItem) {
          try {
            final updatedItem = ClothingItemModel.fromJson(rawItem).toEntity();
            return Right(updatedItem);
          } catch (e) {
            return Left(ValidationFailure(
              message: 'Failed to parse updated item: ${e.toString()}',
              code: 'PARSE_ERROR',
              details: e,
            ));
          }
        },
      );
    } catch (e) {
      return Left(UnknownFailure(
        message: 'Unexpected error while toggling favorite: ${e.toString()}',
        code: 'REPOSITORY_ERROR',
        details: e,
      ));
    }
  }
}
